/*
 * CameraPublishActivity.java
 * CameraPublishActivity
 * 
 * Github: https://github.com/daniulive/SmarterStreaming
 * 
 * Created by DaniuLive on 2015/09/20.
 * Copyright © 2014~2016 DaniuLive. All rights reserved.
 */

package com.daniulive.smartpublisher;

import com.daniulive.smartpublisher.SmartPublisherJni.WATERMARK;
import com.eventhandle.NTSmartEventCallbackV2;
import com.eventhandle.NTSmartEventID;
//import com.voiceengine.NTAudioRecord;	//for audio capture..
import com.voiceengine.NTAudioRecordV2;
import com.voiceengine.NTAudioRecordV2Callback;

import android.annotation.SuppressLint;
import android.app.Activity;
import android.app.AlertDialog;
import android.content.res.Configuration;
import android.graphics.ImageFormat;
import android.graphics.PixelFormat;
import android.hardware.Camera;
import android.hardware.Camera.CameraInfo;
import android.hardware.Camera.Parameters;
import android.hardware.Camera.PreviewCallback;
import android.hardware.Camera.Size;
import android.os.Bundle;
import android.os.Environment;
import android.util.Log;
import android.view.SurfaceHolder;
import android.view.SurfaceHolder.Callback;
import android.view.Surface;
import android.view.SurfaceView;
import android.view.View;
import android.view.View.OnClickListener;
import android.view.WindowManager;
import android.widget.AdapterView;
import android.widget.AdapterView.OnItemSelectedListener;
import android.widget.ArrayAdapter;
import android.widget.Button;
import android.widget.EditText;
import android.widget.ImageView;
import android.widget.Spinner;
import android.widget.TextView;
import android.hardware.Camera.AutoFocusCallback;
import android.content.Context;
import android.content.DialogInterface;
import android.content.Intent;

import java.io.ByteArrayOutputStream;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.List;
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.nio.ByteBuffer;

@SuppressWarnings("deprecation")
public class CameraPublishActivity extends Activity
{
	private static String TAG = "SmartPublisher";
	
	//NTAudioRecord audioRecord_ = null;	//for audio capture
	
	NTAudioRecordV2 audioRecord_ = null;
	
	NTAudioRecordV2Callback audioRecordCallback_ = null;
	
	private TextView textCurURL = null;
	
	private long publisherHandleBack = 0;
	
	private long publisherHandleFront = 0;
	
	private SmartPublisherJniV2 libPublisher = null;
	
	/* 推送类型选择
	 * 0: 音视频
	 * 1: 纯音频
	 * 2: 纯视频
	 * */
	private Spinner pushTypeSelector;
	private int pushType = 0;
	
	/* 水印类型选择
	 * 0: 图片水印
	 * 1: 全部水印
	 * 2: 文字水印
	 * 3: 不加水印
	 * */
	private Spinner watermarkSelctor;
	private int watemarkType = 0;
	
	/* 推流分辨率选择
	 * 0: 640*480
	 * 1: 320*240
	 * 2: 176*144
	 * 3: 1280*720
	 * */
	private Spinner resolutionSelector;
	
	/* video软编码profile设置
     * 1: baseline profile
     * 2: main profile
     * 3: high profile
	 * */
	private Spinner swVideoEncoderProfileSelector;
	
	private int sw_video_encoder_profile = 1;	//default with baseline profile

	private Spinner recorderSelector;
	
	private Button  btnRecoderMgr;
	private Button  btnNoiseSuppression;
	private Button  btnAGC;
	private Button  btnSpeex;
	private Button  btnMute;
	private Button  btnMirror;
	
	private Spinner swVideoEncoderSpeedSelector;
	
	private Button	btnHWencoder;
	private ImageView imgSwitchCamera;
	private Button btnInputPushUrl;
	//private Button btnStartStop;
	
	private Button btnStartPush;
	private Button btnStartRecorder;
	private Button btnCaptureImage;
	
	private SurfaceView mSurfaceViewFront = null;  
    private SurfaceHolder mSurfaceHolderFront = null;  
    
    private SurfaceView mSurfaceViewBack = null;
    private SurfaceHolder mSurfaceHolderBack = null;  
    
    private Camera mCameraFront = null;  
	private AutoFocusCallback myAutoFocusCallbackFront = null;
	
	private Camera mCameraBack = null;
	private AutoFocusCallback myAutoFocusCallbackBack = null;
	
	private boolean mPreviewRunningFront = false;
	private boolean mPreviewRunningBack = false;

	private boolean isStart = false;
	
	private boolean isPushing   = false;
	private boolean isRecording = false;
	
	final private String logoPath = "/sdcard/daniulivelogo.png";
	private boolean isWritelogoFileSuccess = false;
	
	private String publishURL;
	final private String baseURL = "rtmp://player.daniulive.com:1935/hls/stream";
	private String inputPushURL ="";

	private String printText = "URL:";
	private String txt = "当前状态";
		
	private static final int FRONT = 1;		//前置摄像头标记
	private static final int BACK = 2;		//后置摄像头标记
	//private int currentCameraType = BACK;	//当前打开的摄像头标记
	private static final int PORTRAIT = 1;	//竖屏
	private static final int LANDSCAPE = 2;	//横屏
	private int currentOrigentation = PORTRAIT;
	//private int curCameraIndex = -1;
	
	private int curFrontCameraIndex = -1;
	private int curBackCameraIndex  = -1;

	private int videoWidth = 640;
	private int videoHight = 480;
	
	//private int frameCount = 0;
	
	private String recDirFront = "/sdcard/daniulive/recfront";	//for recorder path
	
	private String recDirBack  = "/sdcard/daniulive/recback";
	
	private boolean is_need_local_recorder = false;		// do not enable recorder in default
	
	private boolean is_noise_suppression = true; 
	
	private boolean is_agc = false;
	
	private boolean is_speex = false;
	
	private boolean is_mute = false;
	
	private boolean is_mirror = false;
	
	private int sw_video_encoder_speed = 6;
	
	private boolean is_hardware_encoder = false;
		
    private Context myContext;
    
	private String imageSavePath;
    
	static {  
		System.loadLibrary("SmartPublisher");
	}
  
    
    private byte[] ReadAssetFileDataToByte(InputStream in) throws IOException
    {
        ByteArrayOutputStream bytestream = new ByteArrayOutputStream();
        int c = 0;
        
        while ( (c = in.read()) != -1 )
        {
            bytestream.write(c);
        }
       
        byte bytedata[] = bytestream.toByteArray();
        bytestream.close();
        return bytedata;
    }
    
	@Override
    public void onCreate(Bundle savedInstanceState) 
    {
        Log.i(TAG, "onCreate..");
        
        super.onCreate(savedInstanceState);
        
        getWindow().addFlags(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON); 	//屏幕常亮
        
        setContentView(R.layout.activity_main);

        myContext = this.getApplicationContext();
        
        //设置快照路径(具体路径可自行设置)
        File storageDir = getOwnCacheDirectory(myContext, "daniuimage");//创建保存的路径
        imageSavePath = storageDir.getPath();
        Log.i(TAG, "快照存储路径: " + imageSavePath);
        
		try {

			InputStream logo_input_stream = getClass().getResourceAsStream(
					"/assets/logo.png");

			byte[] logo_data = ReadAssetFileDataToByte(logo_input_stream);

			if (logo_data != null)
			{
				try 
				{
					FileOutputStream out = new FileOutputStream(logoPath);
					out.write(logo_data);
					out.close();
					isWritelogoFileSuccess = true;
				} catch (Exception e) 
				{
					e.printStackTrace();
					Log.e(TAG, "write logo file to /sdcard/ failed");
				}
			}

		} 
		catch (Exception e) 
		{
			e.printStackTrace();
			Log.e(TAG, "write logo file to /sdcard/ failed");
		}
          
        //push type, audio/video/audio&video
        pushTypeSelector = (Spinner)findViewById(R.id.pushTypeSelctor);
        final String []types = new String[]{"音视频", "纯音频", "纯视频"};
        ArrayAdapter<String> adapterType = new ArrayAdapter<String>(this,
                android.R.layout.simple_spinner_item, types);
        adapterType.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item);
        pushTypeSelector.setAdapter(adapterType);

        pushTypeSelector.setOnItemSelectedListener(new OnItemSelectedListener() {

			@Override
			public void onItemSelected(AdapterView<?> parent, View view,
					int position, long id) {
				
				if(isStart || isPushing || isRecording )
				{
					Log.e(TAG, "Could not switch push type during publishing..");
					return;
				}
				
				pushType = position;
				
				Log.i(TAG, "[推送类型]Currently choosing: " + types[position] + ", pushType: " + pushType);
			}

			@Override
			public void onNothingSelected(AdapterView<?> parent) {
				
			}
		});
        //end
        
        //水印
        watermarkSelctor = (Spinner)findViewById(R.id.watermarkSelctor);
        
        final String []watermarks = new String[]{"图片水印", "全部水印", "文字水印", "不加水印"};
        
        ArrayAdapter<String> adapterWatermark = new ArrayAdapter<String>(this,
                android.R.layout.simple_spinner_item, watermarks);
        
        adapterWatermark.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item);
        
        watermarkSelctor.setAdapter(adapterWatermark);

        watermarkSelctor.setOnItemSelectedListener(new OnItemSelectedListener() {

			@Override
			public void onItemSelected(AdapterView<?> parent, View view,
					int position, long id) {
				if(isStart || isPushing || isRecording )
				{
					Log.e(TAG, "Could not switch water type during publishing..");
					return;
				}
				
				watemarkType = position;
				
				Log.i(TAG, "[水印类型]Currently choosing: " + watermarks[position] + ", watemarkType: " + watemarkType);
			}

			@Override
			public void onNothingSelected(AdapterView<?> parent) {
				
			}
		});
        //end
        
        resolutionSelector = (Spinner)findViewById(R.id.resolutionSelctor);
        final String []resolutionSel = new String[]{"高分辨率", "中分辨率", "低分辨率", "超高分辨率"};
        ArrayAdapter<String> adapterResolution = new ArrayAdapter<String>(this,
                android.R.layout.simple_spinner_item, resolutionSel);
        adapterResolution.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item);
        resolutionSelector.setAdapter(adapterResolution);

        resolutionSelector.setOnItemSelectedListener(new OnItemSelectedListener() {

			@Override
			public void onItemSelected(AdapterView<?> parent, View view,
					int position, long id) {
				
				if(isStart|| isPushing || isRecording)
				{
					Log.e(TAG, "Could not switch resolution during publishing..");
					return;
				}
				
				Log.i(TAG, "[推送分辨率]Currently choosing: " + resolutionSel[position]);
				
				SwitchResolution(position);
		
			}

			@Override
			public void onNothingSelected(AdapterView<?> parent) {
				
			}
		});
        
        swVideoEncoderProfileSelector = (Spinner)findViewById(R.id.swVideoEncoderProfileSelector);
        final String []profileSel = new String[]{"BaseLineProfile", "MainProfile", "HighProfile"};
        ArrayAdapter<String> adapterProfile = new ArrayAdapter<String>(this,
                android.R.layout.simple_spinner_item, profileSel);
        adapterProfile.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item);
        swVideoEncoderProfileSelector.setAdapter(adapterProfile);

        swVideoEncoderProfileSelector.setOnItemSelectedListener(new OnItemSelectedListener() {

			@Override
			public void onItemSelected(AdapterView<?> parent, View view,
					int position, long id) {
				
				if(isStart|| isPushing || isRecording)
				{
					Log.e(TAG, "Could not switch video profile during publishing..");
					return;
				}
				
				Log.i(TAG, "[VideoProfile]Currently choosing: " + profileSel[position]);
				
				sw_video_encoder_profile = position + 1;		
			}

			@Override
			public void onNothingSelected(AdapterView<?> parent) {
				
			}
		});
        
        
        //Recorder related settings
        recorderSelector = (Spinner)findViewById(R.id.recoder_selctor);
        
        final String []recoderSel = new String[]{"本地不录像", "本地录像"};
        ArrayAdapter<String> adapterRecoder = new ArrayAdapter<String>(this,
                android.R.layout.simple_spinner_item, recoderSel);
        
        adapterRecoder.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item);
        recorderSelector.setAdapter(adapterRecoder);
        
        recorderSelector.setOnItemSelectedListener(new OnItemSelectedListener() {

			@Override
			public void onItemSelected(AdapterView<?> parent, View view,
					int position, long id) {
						
				Log.i(TAG, "Currently choosing: " + recoderSel[position]);
				
				if ( 1 == position )
				{
					is_need_local_recorder = true;
				}
				else
				{
					is_need_local_recorder = false;
				}
			}

			@Override
			public void onNothingSelected(AdapterView<?> parent) {
				
			}
		});
        
        btnRecoderMgr = (Button)findViewById(R.id.button_recoder_manage);
        btnRecoderMgr.setOnClickListener(new ButtonRecorderMangerListener());
        //end
        
        btnNoiseSuppression = (Button)findViewById(R.id.button_noise_suppression);
        btnNoiseSuppression.setOnClickListener(new ButtonNoiseSuppressionListener());
        
        btnAGC = (Button)findViewById(R.id.button_agc);
        btnAGC.setOnClickListener(new ButtonAGCListener());
        
        btnSpeex = (Button)findViewById(R.id.button_speex);
        btnSpeex.setOnClickListener(new ButtonSpeexListener());
        
        btnMute = (Button)findViewById(R.id.button_mute);
        btnMute.setOnClickListener(new ButtonMuteListener());
        
        btnMirror = (Button)findViewById(R.id.button_mirror);
        btnMirror.setOnClickListener(new ButtonMirrorListener());
        
       
        swVideoEncoderSpeedSelector = (Spinner)findViewById(R.id.sw_video_encoder_speed_selctor);
        
        final String [] video_encoder_speed_Sel = new String[]{"6", "5", "4", "3", "2", "1"};
        ArrayAdapter<String> adapterVideoEncoderSpeed = new ArrayAdapter<String>(this,
                android.R.layout.simple_spinner_item, video_encoder_speed_Sel);
        
        adapterVideoEncoderSpeed.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item);
        swVideoEncoderSpeedSelector.setAdapter(adapterVideoEncoderSpeed);
        
        swVideoEncoderSpeedSelector.setOnItemSelectedListener(new OnItemSelectedListener() {

			@Override
			public void onItemSelected(AdapterView<?> parent, View view,
					int position, long id)
			{
						
				Log.i(TAG, "Currently speed choosing: " + video_encoder_speed_Sel[position]);
				
				sw_video_encoder_speed = 6 - position;
				
				Log.i(TAG, "Choose speed=" + sw_video_encoder_speed);
			}

			@Override
			public void onNothingSelected(AdapterView<?> parent) {
				
			}
		});
        
        
        btnHWencoder = (Button)findViewById(R.id.button_hwencoder);
        btnHWencoder.setOnClickListener(new ButtonHardwareEncoderListener());
        
        textCurURL = (TextView)findViewById(R.id.txtCurURL);
        textCurURL.setText(printText);
        
        btnInputPushUrl =(Button)findViewById(R.id.button_input_push_url);
        btnInputPushUrl.setOnClickListener(new ButtonInputPushUrlListener());
        
        //btnStartStop = (Button)findViewById(R.id.button_start_stop);
        //btnStartStop.setOnClickListener(new ButtonStartListener());
        
        btnStartPush = (Button)findViewById(R.id.button_start_push);
        btnStartPush.setOnClickListener(new ButtonStartPushListener());
        
        btnStartRecorder = (Button)findViewById(R.id.button_start_recorder);
        btnStartRecorder.setOnClickListener(new ButtonStartRecorderListener());
        
        btnCaptureImage = (Button)findViewById(R.id.button_capture_image);
        btnCaptureImage.setOnClickListener(new ButtonCaptureImageListener());
        
        imgSwitchCamera = (ImageView)findViewById(R.id.button_switchCamera);
        imgSwitchCamera.setOnClickListener(new SwitchCameraListener());
        
        mSurfaceViewFront = (SurfaceView) this.findViewById(R.id.surface_front);  
        mSurfaceHolderFront = mSurfaceViewFront.getHolder();  
        mSurfaceHolderFront.addCallback(new NT_SP_SurfaceHolderCallback(FRONT));  
        mSurfaceHolderFront.setType(SurfaceHolder.SURFACE_TYPE_PUSH_BUFFERS); 
        
        //自动聚焦变量回调       
        myAutoFocusCallbackFront = new AutoFocusCallback() 
		{  
            public void onAutoFocus(boolean success, Camera camera) {  
                if(success)//success表示对焦成功  
                {  
                    Log.i(TAG, "Front onAutoFocus succeed...");   
                }  
                else  
                {  
                    Log.i(TAG, "Front onAutoFocus failed...");  
                }  
            }  
        }; 
        
        mSurfaceViewBack = (SurfaceView) this.findViewById(R.id.surface_back);  
        mSurfaceHolderBack = mSurfaceViewBack.getHolder();  
        mSurfaceHolderBack.addCallback(new NT_SP_SurfaceHolderCallback(BACK));  
        mSurfaceHolderBack.setType(SurfaceHolder.SURFACE_TYPE_PUSH_BUFFERS); 
        
        //自动聚焦变量回调       
        myAutoFocusCallbackBack = new AutoFocusCallback() 
		{  
            public void onAutoFocus(boolean success, Camera camera) {  
                if(success)//success表示对焦成功  
                {  
                    Log.i(TAG, "Back onAutoFocus succeed...");   
                }  
                else  
                {  
                    Log.i(TAG, "Back onAutoFocus failed...");  
                }  
            }  
        }; 
        
        libPublisher = new SmartPublisherJniV2();
    }
	
    class SwitchCameraListener implements OnClickListener
    {
        public void onClick(View v)
        {    
        	Log.i(TAG, "Switch camera..");
        	 try {
                 switchCamera();
             } catch (IOException e) {
                 // TODO Auto-generated catch block
                 e.printStackTrace();
             }
         }
    };
    
    void SwitchResolution(int position)
    {
    	Log.i(TAG, "Current Resolution position: " + position);
    	
    	switch(position) {
        case 0:
        	videoWidth = 640;
    		videoHight = 480;
            break;
        case 1:
    		videoWidth = 320;
    		videoHight = 240;
            break;
        case 2:
    		videoWidth = 176;
    		videoHight = 144;
            break;
        case 3:
    		videoWidth = 1280;
    		videoHight = 720;
            break;
        default:
        	videoWidth = 640;
    		videoHight = 480;
    	}
    	
    	Camera front_camera = GetCameraObj(FRONT); 
    	if ( front_camera != null && mSurfaceHolderFront != null )
    	{
    		front_camera.stopPreview();
    		initCamera(FRONT, mSurfaceHolderFront);
    	}
    	
    	Camera back_camera = GetCameraObj(BACK);
    	if ( back_camera != null && mSurfaceHolderBack != null )
    	{
    		back_camera.stopPreview();
    		initCamera(BACK, mSurfaceHolderBack);
    	}
    }
    
    class NTAudioRecordV2CallbackImpl implements NTAudioRecordV2Callback
    { 	
    	 @Override
    	 public void onNTAudioRecordV2Frame(ByteBuffer data, int size, int sampleRate, int channel, int per_channel_sample_number)
    	 {
    		 /*
    		 Log.i(TAG, "onNTAudioRecordV2Frame size=" + size + " sampleRate=" + sampleRate + " channel=" + channel
    				 + " per_channel_sample_number=" + per_channel_sample_number);
    		 
    		 */
    		 
    		 if ( publisherHandleFront != 0 )
    		 {
    			 libPublisher.SmartPublisherOnPCMData(publisherHandleFront, data, size, sampleRate, channel, per_channel_sample_number);
    		 }
    		 
    		 if ( publisherHandleBack != 0 )
    		 {
    			 libPublisher.SmartPublisherOnPCMData(publisherHandleBack, data, size, sampleRate, channel, per_channel_sample_number);
    		 }
    	 }
    }
     
  
    void CheckInitAudioRecorder()
    {
    	if ( audioRecord_ == null )
		{
			 //audioRecord_ = new NTAudioRecord(this, 1);
		
    		audioRecord_ = new NTAudioRecordV2(this);
		}
			
        if( audioRecord_ != null )
        {
        	Log.i(TAG, "CheckInitAudioRecorder call audioRecord_.start()+++...");
        	
        	audioRecordCallback_ = new NTAudioRecordV2CallbackImpl();
        	
        	audioRecord_.AddCallback(audioRecordCallback_);
                	
        	audioRecord_.Start();
        	
        	Log.i(TAG, "CheckInitAudioRecorder call audioRecord_.start()---...");
        	
        	
        	//Log.i(TAG, "onCreate, call executeAudioRecordMethod..");
        	// auido_ret: 0 ok, other failed
        	//int auido_ret= audioRecord_.executeAudioRecordMethod();
        	//Log.i(TAG, "onCreate, call executeAudioRecordMethod.. auido_ret=" + auido_ret); 
        }
    }
    
    //Configure recorder related function.
    
    void ConfigRecorderFuntion(String rec, long handle, boolean isNeedLocalRecorder)
    {
    	if ( libPublisher != null )
    	{
    		if ( isNeedLocalRecorder )
    		{
    			if ( rec != null && !rec.isEmpty() )
        		{
        			int ret = libPublisher.SmartPublisherCreateFileDirectory(rec);
            		if ( 0 == ret )
            		{
            			if ( 0 != libPublisher.SmartPublisherSetRecorderDirectory(handle, rec) )
            			{
            				Log.e(TAG, "Set recoder dir failed , path:" + rec);
            				return;
            			}
            			
            			if ( 0 != libPublisher.SmartPublisherSetRecorder(handle, 1) )
            			{
            				Log.e(TAG, "SmartPublisherSetRecoder failed.");
            				return;
            			}
            			
            			if ( 0 != libPublisher.SmartPublisherSetRecorderFileMaxSize(handle, 200) )
            			{
            				Log.e(TAG, "SmartPublisherSetRecoderFileMaxSize failed.");
            				return;
            			}
            		
            		}
            		else
            		{
            			Log.e(TAG, "Create recoder dir failed, path:" + rec);
            		}
        		}
    		}
    		else
    		{
    			if ( 0 != libPublisher.SmartPublisherSetRecorder(handle, 0) )
    			{
    				Log.e(TAG, "SmartPublisherSetRecoder failed.");
    				return;
    			}
    		}
    	}
    }
    
    void ConfigRecorderFuntion(boolean isNeedLocalRecorder)
    {
    	ConfigRecorderFuntion(recDirFront, publisherHandleFront, isNeedLocalRecorder);
    	ConfigRecorderFuntion(recDirBack, publisherHandleBack, isNeedLocalRecorder);	
    }
    
    class ButtonRecorderMangerListener implements OnClickListener
    {
    	public  void onClick(View v)
    	{
    		if ( mCameraFront != null )
    		{
    			mCameraFront.stopPreview();
    			mCameraFront.release();
    			mCameraFront = null;
    		}
    		
    		if ( mCameraBack != null )
    		{
    			mCameraBack.stopPreview();
    			mCameraBack.release();
    			mCameraBack = null;
    		}
    		
    	    Intent intent = new Intent();
            intent.setClass(CameraPublishActivity.this, RecorderManager.class);
            intent.putExtra("RecoderDir", recDirFront);
            startActivity(intent);
    	}
    }
    
    class ButtonNoiseSuppressionListener  implements OnClickListener
    {
    	public void onClick(View v)
    	{
    		is_noise_suppression = !is_noise_suppression;
    		
    		if ( is_noise_suppression )
    			btnNoiseSuppression.setText("停用噪音抑制");
    		else
    			btnNoiseSuppression.setText("启用噪音抑制");
    	}
    }
    
    class ButtonAGCListener  implements OnClickListener
    {
    	public void onClick(View v)
    	{
    		is_agc = !is_agc;
    		
    		if ( is_agc )
    			btnAGC.setText("停用AGC");
    		else
    			btnAGC.setText("启用AGC");
    	}
    }
    
    class ButtonSpeexListener  implements OnClickListener
    {
    	public void onClick(View v)
    	{
    		is_speex = !is_speex;
    		
    		if ( is_speex  )
    			btnSpeex.setText("不使用Speex");
    		else
    			btnSpeex.setText("使用Speex");
    	}
    }
    
    class ButtonMuteListener  implements OnClickListener
    {
    	public void onClick(View v)
    	{
    		is_mute = !is_mute;
    		
    		if ( is_mute )
    			btnMute.setText("取消静音");
    		else
    			btnMute.setText("静音");
    		
    		if ( libPublisher != null )
    			libPublisher.SmartPublisherSetMute(publisherHandleFront, is_mute?1:0);
    		
    		if ( libPublisher != null )
    			libPublisher.SmartPublisherSetMute(publisherHandleBack, is_mute?1:0);
    	}
    }
    
    class ButtonMirrorListener  implements OnClickListener
    {
    	public void onClick(View v)
    	{
    		is_mirror = !is_mirror;
    		
    		if ( is_mirror )
    			btnMirror.setText("关镜像");
    		else
    			btnMirror.setText("开镜像");
    		
    		if ( libPublisher != null )
    			libPublisher.SmartPublisherSetMirror(publisherHandleFront, is_mirror?1:0);
    		
    		if ( libPublisher != null )
    			libPublisher.SmartPublisherSetMirror(publisherHandleBack, is_mirror?1:0);
    	}
    }
    
    class ButtonHardwareEncoderListener  implements OnClickListener
    {
    	public void onClick(View v)
    	{
    		is_hardware_encoder = !is_hardware_encoder;
    		
    		if ( is_hardware_encoder )
    			btnHWencoder.setText("当前硬解码");
    		else
    			btnHWencoder.setText("当前软解码");
    	}
    }
    
    class EventHandeV2 implements NTSmartEventCallbackV2
    {
    	 @Override
    	 public void onNTSmartEventCallbackV2(long handle, int id, long param1, long param2, String param3, String param4, Object param5){
    		 
    		 Log.i(TAG, "EventHandeV2: handle=" + handle + " id:" + id);
    		 
    		 switch (id) { 
                 case NTSmartEventID.EVENT_DANIULIVE_ERC_PUBLISHER_STARTED:
                	 txt = "开始。。";
                     break;
                 case NTSmartEventID.EVENT_DANIULIVE_ERC_PUBLISHER_CONNECTING:
                	 txt = "连接中。。";
                     break;
                 case NTSmartEventID.EVENT_DANIULIVE_ERC_PUBLISHER_CONNECTION_FAILED:
                	 txt = "连接失败。。";
                     break;
                 case NTSmartEventID.EVENT_DANIULIVE_ERC_PUBLISHER_CONNECTED:
                	 txt = "连接成功。。";
                     break;
                 case NTSmartEventID.EVENT_DANIULIVE_ERC_PUBLISHER_DISCONNECTED:
                	 txt = "连接断开。。";
                     break;
                 case NTSmartEventID.EVENT_DANIULIVE_ERC_PUBLISHER_STOP:
                	 txt =  "关闭。。";
                     break;
                 case NTSmartEventID.EVENT_DANIULIVE_ERC_PUBLISHER_RECORDER_START_NEW_FILE:
                	 Log.i(TAG, "开始一个新的录像文件 : " + param3);
                	 txt = "开始一个新的录像文件。。";
                     break;
                 case NTSmartEventID.EVENT_DANIULIVE_ERC_PUBLISHER_ONE_RECORDER_FILE_FINISHED:
                	 Log.i(TAG, "已生成一个录像文件 : " + param3);
                	 txt = "已生成一个录像文件。。";
                     break;
                     
                 case NTSmartEventID.EVENT_DANIULIVE_ERC_PUBLISHER_SEND_DELAY:
                	 Log.i(TAG, "发送时延: " + param1 + " 帧数:" + param2);
                	 txt = "收到发送时延..";
                	 break;
                	 
                 case NTSmartEventID.EVENT_DANIULIVE_ERC_PUBLISHER_CAPTURE_IMAGE:
                	 Log.i(TAG, "快照: " + param1 + " 路径：" + param3);
                	 
                	 if(param1 == 0)
                	 {
                		 txt = "截取快照成功。."; 
                	 }
                	 else
                	 {
                		 txt = "截取快照失败。."; 
                	 }
                	 break;
             }
             
             String str = "当前回调状态：" + txt;
                          
             Log.i(TAG, str);
             
         }
    }
    
    private void SaveInputUrl(String url)
    {
    	inputPushURL = "";
    	
    	if ( url == null )
    		return;
    	
    	// rtmp://
    	if ( url.length() < 8 )
    	{
    		Log.e(TAG, "Input publish url error:" + url);
    		return;
    	}
    	
    	if ( !url.startsWith("rtmp://") )
    	{
    	    Log.e(TAG, "Input publish url error:" + url);
    		return;
    	}
    		
    	inputPushURL = url;
    	
    	Log.i(TAG, "Input publish url:" + url);
    }
    
    private void PopInputUrlDialog()
    {
    	final EditText inputUrlTxt = new EditText(this);
    	inputUrlTxt.setFocusable(true);
    	inputUrlTxt.setText(baseURL + String.valueOf((int)( System.currentTimeMillis() % 1000000)));

        AlertDialog.Builder builderUrl = new AlertDialog.Builder(this);
        builderUrl.setTitle("如 rtmp://player.daniulive.com:1935/hls/stream123456").setView(inputUrlTxt).setNegativeButton(
                "取消", null);
        
        builderUrl.setPositiveButton("确认", new DialogInterface.OnClickListener() {

                    public void onClick(DialogInterface dialog, int which) {
                        String fullPushUrl = inputUrlTxt.getText().toString();
                        SaveInputUrl(fullPushUrl);
                    }
                });
        
        builderUrl.show();
    }
    
    class ButtonInputPushUrlListener implements OnClickListener
    {
    	 public void onClick(View v)
    	 {
    		 PopInputUrlDialog();
    	 }
    }
    
 
    class ButtonStopListener implements OnClickListener
    {
        public void onClick(View v)
        {    
           //onDestroy();
        }
    };
    
    
    private void ConfigControlEnable(boolean isEnable)
    {
    	btnRecoderMgr.setEnabled(isEnable);
		btnHWencoder.setEnabled(isEnable);
		
		btnNoiseSuppression.setEnabled(isEnable);
		btnAGC.setEnabled(isEnable);
		btnSpeex.setEnabled(isEnable);
    }
    
    
    private void SetConfig(long handle)
    {
    	if ( libPublisher == null )
    		return;
    	
    	if ( handle == 0 )
    		return;
    	
		if ( is_hardware_encoder ) 
		{
			int hwHWKbps = setHardwareEncoderKbps(videoWidth, videoHight);

			Log.i(TAG, "hwHWKbps: " + hwHWKbps);

			int isSupportHWEncoder = libPublisher
					.SetSmartPublisherVideoHWEncoder(handle, hwHWKbps);

			if (isSupportHWEncoder == 0) {
				Log.i(TAG, "Great, it supports hardware encoder!");
			}
		}

		libPublisher.SetSmartPublisherEventCallbackV2(handle, new EventHandeV2());

		// 如果想和时间显示在同一行，请去掉'\n'
		String watermarkText = "大牛直播(daniulive)\n\n";

		String path = logoPath;

		if (watemarkType == 0)
		{
			if (isWritelogoFileSuccess)
				libPublisher.SmartPublisherSetPictureWatermark(handle, path,
								WATERMARK.WATERMARK_POSITION_TOPRIGHT, 160,
								160, 10, 10);
			
		} 
		else if (watemarkType == 1)
		{
			if (isWritelogoFileSuccess)
				libPublisher.SmartPublisherSetPictureWatermark(handle, path,
								WATERMARK.WATERMARK_POSITION_TOPRIGHT, 160,
								160, 10, 10);

			libPublisher.SmartPublisherSetTextWatermark(handle, watermarkText, 1,
					WATERMARK.WATERMARK_FONTSIZE_BIG,
					WATERMARK.WATERMARK_POSITION_BOTTOMRIGHT, 10, 10);

			// libPublisher.SmartPublisherSetTextWatermarkFontFileName("/system/fonts/DroidSansFallback.ttf");

			// libPublisher.SmartPublisherSetTextWatermarkFontFileName("/sdcard/DroidSansFallback.ttf");
		} 
		else if (watemarkType == 2)
		{
			libPublisher.SmartPublisherSetTextWatermark(handle, watermarkText, 1,
					WATERMARK.WATERMARK_FONTSIZE_BIG,
					WATERMARK.WATERMARK_POSITION_BOTTOMRIGHT, 10, 10);

			// libPublisher.SmartPublisherSetTextWatermarkFontFileName("/system/fonts/DroidSansFallback.ttf");
		} else 
		{
			Log.i(TAG, "no watermark settings..");
		}
		// end

		if (!is_speex) 
		{
			// set AAC encoder
			libPublisher.SmartPublisherSetAudioCodecType(handle, 1);
		} 
		else
		{
			// set Speex encoder
			libPublisher.SmartPublisherSetAudioCodecType(handle, 2);
			libPublisher.SmartPublisherSetSpeexEncoderQuality(handle, 8);
		}

		libPublisher.SmartPublisherSetNoiseSuppression(handle, is_noise_suppression ? 1
				: 0);

		libPublisher.SmartPublisherSetAGC(handle, is_agc ? 1 : 0);

		// libPublisher.SmartPublisherSetClippingMode(handle, 0);

		libPublisher.SmartPublisherSetSWVideoEncoderProfile(handle, sw_video_encoder_profile);
		
		libPublisher.SmartPublisherSetSWVideoEncoderSpeed(handle, sw_video_encoder_speed);

		// libPublisher.SetRtmpPublishingType(handle, 0);

		// libPublisher.SmartPublisherSetGopInterval(handle, 40);

		// libPublisher.SmartPublisherSetFPS(handle, 15);
		
		if ( is_hardware_encoder ) 
		{
			libPublisher.SmartPublisherSetFPS(handle, 20);
		}

		// libPublisher.SmartPublisherSetSWVideoBitRate(handle, 600, 1200);
		
		libPublisher.SmartPublisherSaveImageFlag(handle, 1);
		
		libPublisher.SmartPublisherSetClippingMode(handle, 0);
    }
    
    
    private void InitAndSetConfig()
    {
		Log.i(TAG, "videoWidth: " + videoWidth + " videoHight: " + videoHight
				+ " pushType:" + pushType);

		int audio_opt = 1;
		int video_opt = 1;

		if (  pushType == 1) 
		{
			video_opt = 0;
		} 
		else if (pushType == 2)
		{
			audio_opt = 0;
		}

		publisherHandleFront = libPublisher.SmartPublisherOpen(myContext, audio_opt, video_opt,
				videoWidth, videoHight);
	
		Log.i(TAG, "publisherHandleFront=" + publisherHandleFront);
	
		if ( publisherHandleFront != 0 )
		{
			SetConfig(publisherHandleFront);
		}
		
		publisherHandleBack = libPublisher.SmartPublisherOpen(myContext, audio_opt, video_opt,
				videoWidth, videoHight);
		
		Log.i(TAG, "publisherHandleBack=" + publisherHandleBack);
		
		if ( publisherHandleBack != 0 )
		{
			SetConfig(publisherHandleBack);
		}
    }
    
    
    class ButtonStartPushListener implements OnClickListener
    {
        public void onClick(View v)
        {    
        	if ( isStart )
        	{
        		return;
        	}
        	
        	if ( isPushing )
        	{
        		stopPush();
        		
        		if ( !isRecording )
        		{
        			ConfigControlEnable(true);
        		}
        		
        		btnStartPush.setText(" 推送");
        		
        		isPushing = false;
        		
        		return;
        	}
        	
        	
        	Log.i(TAG, "onClick start push..");   
        	
        	if( libPublisher == null )
        		return;
        	
        	isPushing = true;
        	
        	if ( !isRecording )
        	{
        		InitAndSetConfig();
        	}
        	
            if ( inputPushURL != null && inputPushURL.length() > 1 )
			{
				publishURL = inputPushURL;
				Log.i(TAG, "start, input publish url:" + publishURL);
			}
			else
			{
				publishURL = baseURL + String.valueOf((int)( System.currentTimeMillis() % 1000000)); 
				Log.i(TAG, "start, generate random url:" + publishURL);
			}
				
			printText = "URL:" + publishURL;
			        
			Log.i(TAG, printText);
			
			publishURL = "rtmp://player.daniulive.com:1935/hls/streamtfront";
			
			if ( libPublisher.SmartPublisherSetURL(publisherHandleFront, publishURL) != 0 )
			{
			    Log.e(TAG, "Failed to set publish stream URL..");
			}
						
            int startRet = libPublisher.SmartPublisherStartPublisher(publisherHandleFront);
            if( startRet != 0)
            {
            	isPushing = false;
            	
            	Log.e(TAG, "Failed to start push stream..");
            	return;
            }
           
            if ( !isRecording )
            {
            	if( pushType == 0 || pushType ==1 )
      			{
      				CheckInitAudioRecorder();	//enable pure video publisher..
      			}
            }
            
            if ( !isRecording )
            {
            	ConfigControlEnable(false);
            }
            
            textCurURL = (TextView)findViewById(R.id.txtCurURL);
			textCurURL.setText(printText);
				
			btnStartPush.setText(" 停止推送 ");
			
			publishURL = "rtmp://player.daniulive.com:1935/hls/streamtback";
			
			if ( libPublisher.SmartPublisherSetURL(publisherHandleBack, publishURL) != 0 )
			{
			    Log.e(TAG, "Failed to set publish stream URL..");
			}
						
            startRet = libPublisher.SmartPublisherStartPublisher(publisherHandleBack);
            if( startRet != 0)
            {
            	isPushing = false;
            	
            	Log.e(TAG, "Failed to start push stream back..");
            	return;
            }   
        }
        
    };
    
    class ButtonStartRecorderListener implements OnClickListener
    {
        public void onClick(View v)
        {
        	if ( isStart )
        	{
        		return;
        	}
        	
        	if ( isRecording )
        	{
        		stopRecorder();
        		
        		if ( !isPushing )
        		{
        			ConfigControlEnable(true);
        		}
        		
        		btnStartRecorder.setText(" 录像");
        		
        		isRecording = false;
        		
        		return;
        	}
        	
        	
        	Log.i(TAG, "onClick start recorder..");   
        	
        	if( libPublisher == null )
        		return;
        	        	
        	isRecording = true;
        	
        	if ( !isPushing )
        	{
        		InitAndSetConfig();
        	}
        	
        	ConfigRecorderFuntion(true);
        	
            int startRet = libPublisher.SmartPublisherStartRecorder(publisherHandleFront);
            if( startRet != 0 )
            {
            	isRecording = false;
            	
            	Log.e(TAG, "Failed to start recorder.");
            	return;
            }
           
            if ( !isPushing )
            {
            	if( pushType == 0 || pushType ==1 )
      			{
      				CheckInitAudioRecorder();	//enable pure video publisher..
      			}
            }
            
            if ( !isPushing )
            {
            	ConfigControlEnable(false);
            }
            				
            btnStartRecorder.setText(" 停止录像");
            
        
            startRet = libPublisher.SmartPublisherStartRecorder(publisherHandleBack);
            if( startRet != 0)
            {
                isPushing = false;
                     	
                Log.e(TAG, "Failed to start recorder stream.. back");
                return;
            }
                                         
        }
    };
        
    class ButtonCaptureImageListener implements OnClickListener
    {
        @SuppressLint("SimpleDateFormat")
		public void onClick(View v)
        {   	      		
            String timeStamp = new SimpleDateFormat("yyyyMMdd_HHmmss").format(new Date());
            String imageFileName = "dn_" + timeStamp;	//创建以时间命名的文件名称
        	
            String imagePath = imageSavePath + "/" + imageFileName + ".png";
            
       		Log.i(TAG, "imagePath:" + imagePath);
       		
       		if ( publisherHandleFront != 0 )
       		{
       			libPublisher.SmartPublisherSaveCurImage(publisherHandleFront, imagePath);
       		}	
        }
    };
    
    /*
    private void stop()
    {
    	Log.i(TAG, "onClick stop..");
    	StopPublish();
    	isStart = false;
    	btnStartStop.setText(" 开始推流 ");
    }
    */
    
    private void stopPush()
    {
    	if ( !isRecording )
    	{
    		if( audioRecord_ != null )
 	        {
 				Log.i(TAG, "stopPush, call audioRecord_.StopRecording.."); 
 				
 				audioRecord_.Stop();
 				
 				if ( audioRecordCallback_ != null )
 				{
 					audioRecord_.RemoveCallback(audioRecordCallback_);
 					audioRecordCallback_ = null;
 				}
 				
 				audioRecord_ = null;
 				
 				//audioRecord_.StopRecording();
 	        	//audioRecord_ = null;
 	        }
    	}
    	
    	 if ( libPublisher != null && publisherHandleFront != 0 )
    	 {
    		libPublisher.SmartPublisherStopPublisher(publisherHandleFront);
    	 }
    		 
    	 if ( !isRecording )
    	 {
    		 if ( publisherHandleFront != 0 )
    	 	 {
    	 		if ( libPublisher != null )
    	 	    {
    	 	    	libPublisher.SmartPublisherClose(publisherHandleFront);
    	 	    	publisherHandleFront = 0;
    	 	    }
    	 	}
    	 }
    	 
    	 
    	 if ( libPublisher != null && publisherHandleBack != 0 )
    	 {
    		libPublisher.SmartPublisherStopPublisher(publisherHandleBack);
    	 }
    	 
    	 if ( !isRecording )
    	 {
    		 if ( publisherHandleBack != 0 )
    	 	 {
    	 		if ( libPublisher != null )
    	 	    {
    	 	    	libPublisher.SmartPublisherClose(publisherHandleBack);
    	 	    	publisherHandleBack = 0;
    	 	    }
    	 	}
    	 }
    	 
    }
    
    private void stopRecorder()
    {
    	if ( !isPushing )
    	{
    		if( audioRecord_ != null )
 	        {
 				Log.i(TAG, "stopRecorder, call audioRecord_.StopRecording.."); 
 	        	
 				audioRecord_.Stop();
 				
 				if ( audioRecordCallback_ != null )
 				{
 					audioRecord_.RemoveCallback(audioRecordCallback_);
 					audioRecordCallback_ = null;
 				}
 				
 				audioRecord_ = null;
 				
 				//audioRecord_.StopRecording();
 	        	//audioRecord_ = null;
 	        }
    	}
    	
    	if ( libPublisher != null && publisherHandleFront != 0)
    	{
    	   libPublisher.SmartPublisherStopRecorder(publisherHandleFront);
    	}
    	
    	if ( !isPushing )
   	 	{
   		 	if ( publisherHandleFront != 0 )
   		 	{
   		 		if ( libPublisher != null )
   		 		{
   		 			libPublisher.SmartPublisherClose(publisherHandleFront);
   		 			publisherHandleFront = 0;
   		 		}
   		 	}
   	 	}
    	
    	

   	 if ( libPublisher != null && publisherHandleBack != 0)
   	 {
   		libPublisher.SmartPublisherStopRecorder(publisherHandleBack);
   	 }
   	 
   	 
   	 if ( !isPushing )
   	 {
   		 if ( publisherHandleBack != 0 )
   	 	 {
   	 		if ( libPublisher != null )
   	 	    {
   	 	    	libPublisher.SmartPublisherClose(publisherHandleBack);
   	 	    publisherHandleBack = 0;
   	 	    }
   	 	}
   	 }    	
    }

	@Override
    protected  void onDestroy()
	{
    	Log.i(TAG, "activity destory!");
    	
    	/*
    	if ( isStart )
    	{
    		isStart = false;
    		StopPublish();
    		Log.i(TAG, "onDestroy StopPublish");
    	}
    	*/
    	
    	if ( isPushing || isRecording )
    	{
    		if( audioRecord_ != null )
 	        {
 				Log.i(TAG, "surfaceDestroyed, call StopRecording.."); 
 	        	
 				//audioRecord_.StopRecording();
 	        	//audioRecord_ = null;
 				
 				audioRecord_.Stop();
 				
 				if ( audioRecordCallback_ != null )
 				{
 					audioRecord_.RemoveCallback(audioRecordCallback_);
 					audioRecordCallback_ = null;
 				}
 				
 				audioRecord_ = null;
 	        }
    		
    		stopPush();
    		stopRecorder();
    		   		
    		isPushing = false;
    		isRecording = false;
    		
    		if ( publisherHandleFront != 0 )
    		{
    			if ( libPublisher != null )
    	    	{
    	    	    libPublisher.SmartPublisherClose(publisherHandleFront);
    	    	    publisherHandleFront = 0;
    	    	}
    		}
    		
    		if ( publisherHandleBack != 0 )
    		{
    			if ( libPublisher != null )
    	    	{
    	    	    libPublisher.SmartPublisherClose(publisherHandleBack);
    	    	    publisherHandleBack = 0;
    	    	}
    		}
    	}
    	
    	super.onDestroy();
    	finish();
    	System.exit(0);
    }
	
	private void SetCameraFPS(Camera.Parameters parameters)
	{
		if ( parameters == null )
			return;
		
		int[] findRange = null;
		
		int defFPS = 20*1000;
		
		List<int[]> fpsList = parameters.getSupportedPreviewFpsRange();
		if ( fpsList != null && fpsList.size() > 0 )
		{
			for ( int i = 0; i < fpsList.size(); ++i )
			{
				int[] range = fpsList.get(i);
				if ( range != null 
						&& Camera.Parameters.PREVIEW_FPS_MIN_INDEX <  range.length 
						 && Camera.Parameters.PREVIEW_FPS_MAX_INDEX < range.length )
				{
					Log.i(TAG, "Camera index:" + i + " support min fps:" + range[Camera.Parameters.PREVIEW_FPS_MIN_INDEX]);
					
					Log.i(TAG, "Camera index:" + i + " support max fps:" + range[Camera.Parameters.PREVIEW_FPS_MAX_INDEX]);	
						
					if ( findRange == null )
					{
						if ( defFPS <= range[Camera.Parameters.PREVIEW_FPS_MAX_INDEX] )
						{
							findRange = range;
							
							Log.i(TAG, "Camera found appropriate fps, min fps:" + range[Camera.Parameters.PREVIEW_FPS_MIN_INDEX]
									+ " ,max fps:" + range[Camera.Parameters.PREVIEW_FPS_MAX_INDEX]);
						}
					}
				}
			}
		}
		
		if ( findRange != null  )
		{
			parameters.setPreviewFpsRange(findRange[Camera.Parameters.PREVIEW_FPS_MIN_INDEX], findRange[Camera.Parameters.PREVIEW_FPS_MAX_INDEX]);
		}
	}

	/*it will call when surfaceChanged*/
	private void initCamera(int camera_type, SurfaceHolder holder)
	{  
		Log.i(TAG, "initCamera..");
		
		Camera camera = GetCameraObj(camera_type);
		if ( camera == null )
		{
			Log.e(TAG, "initCamera camera is null, type=" + camera_type);
			return;
		}
		
		int cameraIndex = GetCameraIndex(camera_type);
		if ( -1 == cameraIndex )
		{
			Log.e(TAG, "initCamera cameraIndex is -1, type=" + camera_type);
			return;
		}
		
		if ( FRONT == camera_type )
		{
			if ( mPreviewRunningFront )
			{
				camera.stopPreview();
			}
		}
		else if ( BACK == camera_type )
		{
			if ( mPreviewRunningBack )
			{
				camera.stopPreview();
			}
		}
			
		Camera.Parameters parameters;
		try {
			parameters = camera.getParameters();
		} catch (Exception e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
			return;
		}
			
		parameters.setPreviewSize(videoWidth, videoHight);
		parameters.setPictureFormat(PixelFormat.JPEG); 
		parameters.setPreviewFormat(PixelFormat.YCbCr_420_SP); 
		
		SetCameraFPS(parameters);
		
		setCameraDisplayOrientation(this, cameraIndex, camera);
        
		camera.setParameters(parameters); 
		
		int bufferSize = (((videoWidth|0xf)+1) * videoHight * ImageFormat.getBitsPerPixel(parameters.getPreviewFormat())) / 8;
		
		camera.addCallbackBuffer(new byte[bufferSize]);
		
		camera.setPreviewCallbackWithBuffer(new NT_SP_CameraPreviewCallback(camera_type));  
        
		try
        {  
        	camera.setPreviewDisplay(holder);  
        } catch (Exception ex) {
        	// TODO Auto-generated catch block 
        	if(null != camera)
        	{  
        		camera.release();  
        		camera = null;
        		SetCameraObj(camera_type, null);
            }
        	ex.printStackTrace();
        }  
        
		if ( camera != null )
		{
			camera.startPreview();  
		}
        
        if ( FRONT == camera_type )
        {
        	camera.autoFocus(myAutoFocusCallbackFront);
        	mPreviewRunningFront = true;  	
        }
        else if ( BACK == camera_type )
        {
        	camera.autoFocus(myAutoFocusCallbackBack);
        	mPreviewRunningBack = true; 
        }
	}  
	
	int GetCameraIndex(int type)
	{
		if ( FRONT == type )
		{
			return curFrontCameraIndex;
		}
		else if ( BACK == type )
		{
			return curBackCameraIndex;
		}
		else
		{
			Log.i(TAG, "GetCameraIndex type error, type=" + type);
			return -1;
		}
	}
	
	Camera GetCameraObj(int type)
	{
		if ( FRONT == type )
		{
			return mCameraFront;
		}
		else if ( BACK == type )
		{
			return mCameraBack;
		}
		else
		{
			Log.i(TAG, "GetCameraObj type error, type=" + type);
			return null;
		}
	}
	
	void SetCameraObj(int type, Camera c)
	{
		if ( FRONT == type )
		{
			mCameraFront = c;
		}
		else if ( BACK == type )
		{
			mCameraBack = c;
		}
		else
		{
			Log.i(TAG, "SetCameraObj type error, type=" + type);
		}
	}
	
	class NT_SP_SurfaceHolderCallback implements Callback
	{
		private int type_ = 0;
		
		public NT_SP_SurfaceHolderCallback(int type)
		{
			type_ = type;
		}
		
		@Override
		public void surfaceCreated(SurfaceHolder holder) {
			
			Log.i(TAG, "surfaceCreated..type_=" + type_);
			
			if ( type_ != FRONT && type_ != BACK )
			{
				Log.e(TAG, "surfaceCreated type error, type=" + type_);
				return;
			}
			
			try {
				
				if ( type_ == FRONT )
				{
					int cammeraIndex = findFrontCamera();
					if( cammeraIndex == -1 )
		            {
		            	Log.e(TAG, "surfaceCreated, There is no front camera!!");
		            	return;
		            }  
				}
				else if ( type_ == BACK )
				{
					int cammeraIndex = findBackCamera();
					if ( -1 == cammeraIndex )
					{
						Log.e(TAG, "surfaceCreated, there is no back camera");
						
						return;
					}
				}
				
				if ( GetCameraObj(type_) == null )
				{
					Camera c = openCamera(type_); 
					SetCameraObj(type_, c);
				}
		        
	        } catch (Exception e) {
	            e.printStackTrace();
	        }
		}
		
		@Override
		public void surfaceChanged(SurfaceHolder holder, int format, int width, int height) {
			Log.i(TAG, "surfaceChanged..");
			
			if ( type_ != FRONT && type_ != BACK )
				return;
			
			initCamera(type_, holder);
		}

		@Override
		public void surfaceDestroyed(SurfaceHolder holder) {
			// TODO Auto-generated method stub
			Log.i(TAG, "Surface Destroyed"); 
		}
	}
	
	
	public void onConfigurationChanged(Configuration newConfig) {  
        try {  
            super.onConfigurationChanged(newConfig);  
        	Log.i(TAG, "onConfigurationChanged, start:" + isStart);
            if (this.getResources().getConfiguration().orientation == Configuration.ORIENTATION_LANDSCAPE) { 
            	if(!isStart && !isPushing && !isRecording) {
            		currentOrigentation = LANDSCAPE;
				}
            } else if (this.getResources().getConfiguration().orientation == Configuration.ORIENTATION_PORTRAIT) {
            	if(!isStart && !isPushing && !isRecording ) {
            		currentOrigentation = PORTRAIT;
				}
            }  
        } catch (Exception ex) {  
        }  
    }

	
	class NT_SP_CameraPreviewCallback implements PreviewCallback
	{
		private int type_ = 0;
		
		private int frameCount_ = 0;
		
		public NT_SP_CameraPreviewCallback(int type)
		{
			type_ = type;
		}
		
		@Override
		public void onPreviewFrame(byte[] data, Camera camera) {
			
			frameCount_++;
			if ( frameCount_ % 5000 == 0 )
			{
				//Log.i("OnPre", "gc+");
				System.gc();
				//Log.i("OnPre", "gc-");
			}
		
			if (data == null) {
				Parameters params = camera.getParameters();
				Size size = params.getPreviewSize();
				int bufferSize = (((size.width|0x1f)+1) * size.height * ImageFormat.getBitsPerPixel(params.getPreviewFormat())) / 8;
				camera.addCallbackBuffer(new byte[bufferSize]);
			} 
			else 
			{
				if( isStart|| isPushing || isRecording )
				{
					if ( FRONT == type_ && publisherHandleFront != 0 )
					{
						libPublisher.SmartPublisherOnCaptureVideoData(publisherHandleFront, data, data.length, FRONT, currentOrigentation);
					}
					
					if ( BACK == type_ && publisherHandleBack != 0 )
					{
						libPublisher.SmartPublisherOnCaptureVideoData(publisherHandleBack, data, data.length, BACK, currentOrigentation);
					}
				}
				
				camera.addCallbackBuffer(data);
			}
		} 
	}

	
    @SuppressLint("NewApi")
    private Camera openCamera(int type){
        
    	int frontIndex =-1;
        int backIndex = -1;
        int cameraCount = Camera.getNumberOfCameras();
        Log.i(TAG, "cameraCount: " + cameraCount);
        
        CameraInfo info = new CameraInfo();
        for(int cameraIndex = 0; cameraIndex<cameraCount; cameraIndex++){
            Camera.getCameraInfo(cameraIndex, info);
            
            if(info.facing == CameraInfo.CAMERA_FACING_FRONT){
                frontIndex = cameraIndex;
            }else if(info.facing == CameraInfo.CAMERA_FACING_BACK){
                backIndex = cameraIndex;
            }
        }
        
        if( type == FRONT && frontIndex != -1) {
        	curFrontCameraIndex = frontIndex;
            return Camera.open(frontIndex);
        }else if(type == BACK && backIndex != -1) {
        	curBackCameraIndex = backIndex;
            return Camera.open(backIndex);
        }
        
        return null;
    }
	
	 private void switchCamera() throws IOException{
	    /*
		  
		 mCamera.setPreviewCallback(null);
		 	mCamera.stopPreview();
		 	mCamera.release();
	        if(currentCameraType == FRONT){
	        	mCamera = openCamera(BACK);
	        }else if(currentCameraType == BACK){
	        	mCamera = openCamera(FRONT);
	        }
	        
	        initCamera(mSurfaceHolder);
	        
	      */
	    }
	 
	 /*
	 private void StopPublish()
	 {
		 if(audioRecord_ != null)
	        {
				Log.i(TAG, "surfaceDestroyed, call StopRecording.."); 
	        	audioRecord_.StopRecording();
	        	audioRecord_ = null;
	        }
         
		 if ( libPublisher != null )
		 {
			 libPublisher.SmartPublisherStop();
		 }
	 }*/
	
	//Check if it has front camera
	private int findFrontCamera(){	
        int cameraCount = 0;
        Camera.CameraInfo cameraInfo = new Camera.CameraInfo();
        cameraCount = Camera.getNumberOfCameras(); 
        
        for ( int camIdx = 0; camIdx < cameraCount;camIdx++ ) {
            Camera.getCameraInfo( camIdx, cameraInfo );
            if ( cameraInfo.facing ==Camera.CameraInfo.CAMERA_FACING_FRONT ) {
               return camIdx;
            }
        }
    	return -1;
    }
	
	//Check if it has back camera
    private int findBackCamera(){
        int cameraCount = 0;
        Camera.CameraInfo cameraInfo = new Camera.CameraInfo();
        cameraCount = Camera.getNumberOfCameras();
              
        for ( int camIdx = 0; camIdx < cameraCount;camIdx++ ) {
            Camera.getCameraInfo( camIdx, cameraInfo );
            if ( cameraInfo.facing ==Camera.CameraInfo.CAMERA_FACING_BACK ) {
               return camIdx;
            }
        }
    	return -1;
    }
    
    private void setCameraDisplayOrientation (Activity activity, int cameraId, android.hardware.Camera camera) {  
        android.hardware.Camera.CameraInfo info = new android.hardware.Camera.CameraInfo();  
        android.hardware.Camera.getCameraInfo (cameraId , info);  
        int rotation = activity.getWindowManager ().getDefaultDisplay ().getRotation ();  
        int degrees = 0;  
        switch (rotation) {  
            case Surface.ROTATION_0:  
                degrees = 0;  
                break;  
            case Surface.ROTATION_90:  
                degrees = 90;  
                break;  
            case Surface.ROTATION_180:  
                degrees = 180;  
                break;  
            case Surface.ROTATION_270:  
                degrees = 270;  
                break;  
        }  
        int result;  
        if (info.facing == Camera.CameraInfo.CAMERA_FACING_FRONT) {  
            result = (info.orientation + degrees) % 360;  
            result = (360 - result) % 360;  
        } else {  
            // back-facing  
            result = ( info.orientation - degrees + 360) % 360;  
        }  
        
    	Log.i(TAG, "curDegree: "+ result); 
    	
        camera.setDisplayOrientation (result);  
    }
    
    private int setHardwareEncoderKbps(int width, int height)
    {
    	int hwEncoderKpbs = 0;
    	
    	switch(width) {
        case 176:
        	hwEncoderKpbs = 220;
            break;
        case 320:
        	hwEncoderKpbs = 380;
            break;
        case 640:
        	hwEncoderKpbs = 560;
            break;
        case 1280:
        	hwEncoderKpbs = 1200;
            break;
        default:
        	hwEncoderKpbs = 1000;
    	}
    	
    	return hwEncoderKpbs;
    }
    
	/**
     * 根据目录创建文件夹
     * @param context
     * @param cacheDir
     * @return
     */
    public static File getOwnCacheDirectory(Context context, String cacheDir) {
        File appCacheDir = null;
        //判断sd卡正常挂载并且拥有权限的时候创建文件
        if ( Environment.MEDIA_MOUNTED.equals(Environment.getExternalStorageState()) && hasExternalStoragePermission(context)) {
            appCacheDir = new File(Environment.getExternalStorageDirectory(), cacheDir);
        	Log.i(TAG, "appCacheDir: " + appCacheDir);
        }
        if (appCacheDir == null || !appCacheDir.exists() && !appCacheDir.mkdirs()) {
            appCacheDir = context.getCacheDir();
        }
        return appCacheDir;
    }

    /**
     * 检查是否有权限
     * @param context
     * @return
     */
    private static boolean hasExternalStoragePermission(Context context) {
        int perm = context.checkCallingOrSelfPermission("android.permission.WRITE_EXTERNAL_STORAGE");
        return perm == 0;
    }
   
}